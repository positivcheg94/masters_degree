\section{Потокова модель задачі обчислень множення матриць}

Нехай система складається з $m$ обчислювальних вузлів та кожен з них характеризується швидкістю роботи $p_i , i=1,\ldots,m$ – тобто кількістю операцій з плаваючою точкою за секунду, які він може здійснити. Процесори з’єднані лініями зв’язку з планувальником, який передає задачі та приймає від них результат. Будемо вважати, що лінії зв’язку ідентичні та мають швидкість передачі даних $q$ та затримку $l$.
Будемо вважати, що виконуються наступні припущення
\begin{itemize}
	\item Всі процесори починають роботу одночасно
	\item Планувальник здійснює призначення миттєво
\end{itemize}

Нехай задані дві квадратні матриці розмірності $N \times N$ , результат множення яких необхідно обчислити. При використанні блочного алгоритму користувач задає розмір блоку $n$ , в результаті чого формуються $k=\frac{N^2}{n^2}$  задач, кожна з яких буде мати складність $\mathcal{O}(n^2)$ . Припустимо, що планувальник забезпечує пересилку повідомлень на вузли за певним фіксованим алгоритмом, який завершує обчислення за час $T(N,n)$. Тоді задача користувача полягає у пошуку мінімуму функції:

\begin{equation}
	\label{eq:general_minimization_problem}
	T(N,n) \longrightarrow \min
\end{equation}

Функція $T(N,n)$ може мати багато локальних мінімумів в залежності від конфігурації системи. Ілюстрації графіків функції, отриманої шляхом симуляції, наведені у експериментальній частині та корелють з отриманими результатами у \cite{DoroshenkoIgnatenkoIvanenko}.

Одним з розповсюджених підходів до аналізу таких задач полягає у дослідженні потокової моделі даного процесу \cite{FluidModelForJobScheduling}.

Припустимо, що користувач вибрав вектор $x \in \mathbb{R}$ з компонентами $x_i$, де $x_i > 0$ , $x_i \le k$, $i=1,\ldots,m$, $\sum_{i=1}^{k}x_i = k$. Всі таки вектори утворюють множину $X(n)$ . Кожен компонент вектора $x$ описує відсоток задач, призначених для виконання на  $i$-тому процесорі. Будемо брати до уваги тільки операції, множення. Таке спрощення дозволяє у явному вигляді виписати функції часу. Загальний час закінчення залежить від  $x$, та дорівнює:

\begin{equation}
	\label{eq:total_time_general}
	T(x,X(n)) = \max\limits_{i=1,\ldots,m}{\frac{x_i N n^2}{p_i}}
\end{equation}

Потокова модель передбачає можливість розділення задачі на підзадачі розміру $\epsilon = N n^2$, компонування з них підходящих підзадач та визначення загального часу при  $\epsilon \longrightarrow 0$.

Твердження 1.
Мінімальний час обчислень для потокової моделі з одним користувачем дорівнює:
\begin{equation}
	\label{eq:lema1}
	T = \frac{N^{3}}{\sum_{i=1}^{m}p_i}
\end{equation}

Згізно з цим користувач має розділити задачі так, щоб вузол $i$ отримав задач з сумарною складністю $p_i*T$ часу.

Функція Мінковського для множини $X$ та вектора $p \in \mathbb{R}^m$ визначається наступним чином:

\begin{equation}
	\mu_X(p) = inf {\lambda > 0 : p \in \lambda X}
\end{equation}

Відомо, що ця функція опукла для опуклої $X$.
Визначимо множину потужностей системи $R = {r \in \mathbb{R}^m : r_i \in [0, p_i]}$ та масштабуємо її наступним чином:

\begin{equation}
	R(n) = \frac{R}{Nn^2}
\end{equation}

Тоді $ T(x, X(n)) = \mu_{R(n)}(x) $.
\\
Доведення.
\\
Розглянемо праву частину: $\mu_{R(n)}(x) = inf {\lambda > 0 : x \in \lambda R(n)}$ Умова належності вектора $x$ множині $R$ записується як $\max\limits_{i=1,\ldots,m} \frac{x_i Nn^2}{p_i}$,а значить $\mu_{X(n)}(p) = inf \big\{ \lambda > 0 : \max\limits_{i=1,\ldots,m} \frac{x_i}{p_i} = \frac{\lambda}{Nn^2} \big\}$. Або $\lambda = \max\limits_{i=1,\ldots,m} \frac{x_i Nn^2}{p_i}$. З властивостей функції $mu_{X(n)}(x)$ випливає, що мінімальний час $T_{min} = \min\limits_{x \in X(n)} $ існує і єдиний. Для врахування пересилок та затримки з'єднання потрібно зазначити, що алгоритм надсилає $2x_iNn$ елементів ( $x_i$ пар матриць розмірів $n*N$ ) на відповідний вузол $i$ та приймає $x_i*n^2$ елементів ( $x_i$ результатів множення матриць $n*N$ та $N*n$).

Отже, сумарний час закінчення з урахуванням пересилок та затримок дорівнює:
\begin{equation}
	\label{eq:main_time}
	T_s(x,X(n)) = \max\limits_{i=1,\ldots,m} \bigg\{ \frac{x_i N n^2}{p_i} + \frac{x_i (n^2 + 2 N n )}{q} + x_i l \bigg\}
\end{equation}

Твердження 2. Існує мінімум часу по $x - \min\limits_{x \in X(n)} T_s(x, X(n))$

\section{Аналіз штрафів від величини розбиття}

У цьому підрозділі ми проведемо аналіз того, як величина розбиття впливає на час виконання задач у потоковій моделі.

Як ми бачимо з \ref{eq:main_time}, наявні 2 види штрафів від дрібності розбиття. Перший вид з'являється через надлишковість передачі даних при розбитті матриці на підматриці, а другий напряму від кількості задач, що утворились в результаті розбиття.

Пронормуємо $x_i$:
\begin{equation}
	\label{eq:d_i}
	d_i = \frac{x_i}{\sum\limits_{i=1,\ldots,m} x_i} = \frac{x_i}{k}
\end{equation}

Таким чином $d_i$ це доля обчислень вузла $i$, $d_i \in [0, 1], \sum\limits_{i=1,\ldots,m} d_i = 1$. І навпаки, $x_i = d_i * k = d_i * \frac{N^2}{n^2}$

Перепишемо \ref{eq:main_time} за допомоги $d_i$:

\begin{equation}
	\label{eq:main_time_d_i}
	T_s(x,X(n)) = \max\limits_{i=1,\ldots,m} \bigg\{ \frac{d_i k N n^2}{p_i} + \frac{d_i k(n^2 + 2 N n )}{q} + d_i k l \bigg\}
\end{equation}

Проте нас більше всього цікавить рівняння із заміною $k = \frac{N^2}{n^2}$.

\begin{equation}
\label{eq:main_time_d_i_2}
T_s(x,X(n)) = \max\limits_{i=1,\ldots,m} \bigg\{ \frac{d_i \frac{N^2}{n^2} N n^2}{p_i} + \frac{d_i \frac{N^2}{n^2}(n^2 + 2 N n )}{q} + d_i \frac{N^2}{n^2} l \bigg\}
\end{equation}

Після скорочення отримаємо:

\begin{equation}
\label{eq:main_time_d_i_final}
T_s(x,X(n)) = \max\limits_{i=1,\ldots,m} \bigg\{ d_i \frac{N^3}{p_i} + d_i \frac{N^2 ( 1 + 2*\frac{N}{n} )}{q} + d_i \frac{N^2}{n^2} l \bigg\}
\end{equation}

Позначимо за $T_i$ час роботи вузла $i$, тоді:
\begin{equation}
	\begin{split}
		T_i = d_i \frac{N^3}{p_i} + d_i \frac{N^2 ( 1 + 2*\frac{N}{n} )}{q} + d_i \frac{N^2}{n^2} l
		\\
		T_s(x,X(n)) = \max\limits_{i=1,\ldots,m} T_i
	\end{split}
\end{equation}

Виділимо окремі складові $T_i$:
\begin{equation}
	\begin{split}
		A_i = \frac{N^3}{p_i}
		\\
		B_i = \frac{N^2 ( 1 + 2*\frac{N}{n} )}{q}
		\\
		C_i = \frac{N^2}{n^2} l
		\\
		T_i = d_i ( A_i + B_i + C_i )
	\end{split}
\label{eq:T_i_parts}
\end{equation}

Таким чином ми розділили час виконання на 3 окремі складові, кожна з яких має свій сенс. Перша складова $A_i$ відповідає за сумарну складність алгоритма множення двох матриць без розбиття. Друга складова $B_i$ відповідає за надлишковість передачі даних і третя $C_i$ за затримки.


\section{Дискретна версія моделі обчислень множення матриць}
Нехай розмір блоку $n$ є дільником $N$, тоді задача множення матриць $N*N$ та $N*N$ поділяється на $k = \frac{N^2}{n^2}$ паралельних задач множення матриць $n*N$ та $N*n$.
У порівнянні з потоковою моделю, дискретний варіант має скінченну множину комбінацій розподілу задач планувальником на обчислювальні вузли.

Визначимо множину $Y(n)$ по аналогії з $X(n)$:

\begin{equation}
	\label{eq:Y(n)}
	Y(n) = \big\{y \in R^m : y_i \in {0, \ldots, k}, \sum_{j = 1}^{m} y_j = k, i = 1,\ldots,m \big\}
\end{equation}

Оскільки $Y(n)$ це дискретний варіант $X(n)$, то очевидне включення $Y(n) \subset X(n)$.
Задача планувальника є саме вибір конкретного вектора $y \in Y(n)$.
У роботі досліджуються планувальники типу $extr_1 extr_2$ - min min, min max, max min та max max. Принцип роботи їх дуже простий.

\begin{itemize}
	\item[1] Формується черга задач
	\item[2] Із черги задач вилучається задача згідно з конфігурацією $extr_1$. $min$ конфігурація вибирає задачу із черги з найменшою складністю, а $max$ з найбільшою
	\item[3] Вилучена з черги задача надсилається на вільний процесор згідно з правилом $extr2$. $min$ конфігурація має на меті виконати задачу за найкоротший час і вибирає вільний процесор з найбільшою потужністю, а $max$ навпаки - з найменшою
	\item[4] Якщо черга задач не пуста, то повернутися на крок 2
\end{itemize}

\section{Некооперативна ігрова модель планування множення матриць для двох користувачів}

Сформулюємо концепції гри між двома гравцями, бажання яких є виконання задачі множення матриць у розподіленому середовищі з паралелізацією методом розбиття матриць на блоки.

Нехай у загальному випадку ця гра проводиться між гравцями ${u_i}, i=1,\ldots,L$. Усі гравці мають рівний доступ до розподіленого середовища через спільний інтерфейс планувальника. Кожен з гравців може зареєструвати певний набір задач і після цього

Некооперативна гра описує процес прийняття рішення про розбиття двома гравцями в умовах конфлікту інтересів. Кожен гравець хоче виконати паралельне множення матриць якможна швидше. Конфлікт полягає у тому, що зміна стратегії розбиття одним гравцем

